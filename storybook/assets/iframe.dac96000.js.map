{"version":3,"file":"iframe.dac96000.js","sources":["../../../vite/modulepreload-polyfill","../../../.storybook/preview.js","../../../src/lib/raw-api.ts","../../../src/lib/api.ts","../../../src/lib/Terms.svelte","../../../src/lib/Autocomplete.svelte","../../../src/stories/Autocomplete.stories.svelte","../../../src/lib/Categories.svelte","../../../src/stories/Categories.stories.svelte","../../../src/lib/Gif.svelte","../../../src/lib/Grid.svelte","../../../src/lib/Search.svelte","../../../src/lib/MobileKeyboard.svelte","../../../src/stories/MobileKeyboard.stories.svelte","../../../src/lib/Related.svelte","../../../src/stories/Related.stories.svelte","../../../src/stories/Search.stories.svelte","../../../src/lib/ShuffledSearch.svelte","../../../src/stories/ShuffledSearch.stories.svelte","../../../src/lib/Trending.svelte","../../../src/stories/Trending.stories.svelte","../../../src/lib/TrendingTerms.svelte","../../../src/stories/TrendingTerms.stories.svelte","../../../../../../../../virtual:/@storybook/builder-vite/vite-app.js"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","export const parameters = {\n  actions: { argTypesRegex: '^on[A-Z].*' },\n  controls: {\n    matchers: {\n      color: /(background|color)$/i,\n      date: /Date$/,\n    },\n  },\n}\n","/**\n * A direct implementation of Tenor's API.\n *\n * @module\n */\n\n/*\n █████  ██████  ██     ████████ ██    ██ ██████  ███████ ███████\n██   ██ ██   ██ ██        ██     ██  ██  ██   ██ ██      ██\n███████ ██████  ██        ██      ████   ██████  █████   ███████\n██   ██ ██      ██        ██       ██    ██      ██           ██\n██   ██ ██      ██        ██       ██    ██      ███████ ███████\n*/\n\nexport interface GifObject<Formats extends string = GifFormat> {\n  /** Tenor result identifier. */\n  id: string\n  /** The title of the post. */\n  title: string\n  /** **Not documented**. Description of the GIF content. */\n  content_description: string\n  /** An array of tags for the post. */\n  tags: string[]\n  /** The full URL to view the post on tenor.com. */\n  itemurl: string\n  /** A short URL to view the post on tenor.com. */\n  url: string\n  /** A unix timestamp representing when this post was created. */\n  created: number\n  /**\n   * True if this post contains audio (only video formats support audio, the gif\n   * image file format can not contain audio information).\n   */\n  hasaudio: boolean\n  /** True if this post contains captions. */\n  hascaption: boolean\n  /**\n   * An array of dictionaries with {@link GifFormat} as the key and\n   * {@link MediaObject} as the value.\n   *\n   * @remarks\n   *   It looks like the array only contains one element.\n   */\n  media: { 0: Record<Formats, MediaObject> }\n}\n\nexport interface MediaObject {\n  /** A url to a preview image of the media source. */\n  preview: string\n  /** A url to the media source. */\n  url: string\n  /** Width and height in pixels. */\n  dims: [number, number]\n  /** Size of file in bytes. */\n  size: number\n}\n\nexport type GifFormat =\n  | 'gif'\n  | 'mediumgif'\n  | 'tinygif'\n  | 'nanogif'\n  | 'mp4'\n  | 'loopedmp4'\n  | 'tinymp4'\n  | 'nanomp4'\n  | 'webm'\n  | 'tinywebm'\n  | 'nanowebm'\n\nexport interface ApiError {\n  /** An optional numeric code. */\n  code: number\n  /** A string message describing the error. */\n  error: string\n}\n\n/*\n███████ ███    ██ ██████  ██████   ██████  ██ ███    ██ ████████     ████████ ██    ██ ██████  ███████ ███████\n██      ████   ██ ██   ██ ██   ██ ██    ██ ██ ████   ██    ██           ██     ██  ██  ██   ██ ██      ██\n█████   ██ ██  ██ ██   ██ ██████  ██    ██ ██ ██ ██  ██    ██           ██      ████   ██████  █████   ███████\n██      ██  ██ ██ ██   ██ ██      ██    ██ ██ ██  ██ ██    ██           ██       ██    ██      ██           ██\n███████ ██   ████ ██████  ██       ██████  ██ ██   ████    ██           ██       ██    ██      ███████ ███████\n*/\n\nexport interface CommonOptions {\n  /** Client key. You may use `LIVDSRZULELA` for testing. */\n  key: string\n  /**\n   * Default language to interpret search string.\n   *\n   * @default `en_US`\n   */\n  locale?: string\n  /**\n   * Specify the content safety filter level. Possible values:\n   *\n   * - **High** - G\n   * - **Medium** - G and PG\n   * - **Low** - G, PG, and PG-13\n   * - **Off** - G, PG, PG-13, and R (no nudity)\n   *\n   * @default `off`\n   * @see https://tenor.com/gifapi/documentation#contentfilter\n   */\n  contentfilter?: 'off' | 'low' | 'medium' | 'high'\n  /**\n   * Filter the response GIF_OBJECT list to only include GIFs with aspect ratios\n   * that fit with in the selected range.\n   *\n   * - **All** - no constraints\n   * - **Wide** - 0.42 <= aspect ratio <= 2.36\n   * - **Standard** - 0.56 <= aspect ratio <= 1.78\n   *\n   * @default `all`\n   */\n  ar_range?: 'all' | 'wide' | 'standard'\n  /**\n   * Fetch up to a specified number of results (max: 50).\n   *\n   * @default 20\n   */\n  limit?: number\n  /**\n   * GGt results starting at position \"value\". Use a non-zero \"next\" value\n   * returned by API results to get the next set of results.\n   */\n  pos?: string\n  /** Specify the anonymous_id tied to the given user. */\n  anon_id?: string\n}\n\nexport interface CommonSearchOptions extends CommonOptions {\n  /** Search string. */\n  q: string\n}\nexport interface CommonResults<Formats extends string = GifFormat> {\n  next: string\n  results: Array<GifObject<Formats>>\n}\nexport type MinimalResults = CommonResults<'gif' | 'tinygif' | 'mp4'>\nexport type BasicResults = CommonResults<\n  'gif' | 'tinygif' | 'nanogif' | 'mp4' | 'tinymp4' | 'nanomp4'\n>\n\n/*\n███████ ███    ██ ██████  ██████   ██████  ██ ███    ██ ████████ ███████\n██      ████   ██ ██   ██ ██   ██ ██    ██ ██ ████   ██    ██    ██\n█████   ██ ██  ██ ██   ██ ██████  ██    ██ ██ ██ ██  ██    ██    ███████\n██      ██  ██ ██ ██   ██ ██      ██    ██ ██ ██  ██ ██    ██         ██\n███████ ██   ████ ██████  ██       ██████  ██ ██   ████    ██    ███████\n*/\n\n/** Creates an endpoint. */\nexport const endpoint =\n  <Input, Output>(name: string) =>\n  async (options: Input): Promise<Output> => {\n    const url = new URL(`https://g.tenor.com/v1/${name}`)\n    for (const [name, value] of Object.entries(options))\n      if (value !== undefined) url.searchParams.set(name, value.toString())\n\n    const response = await fetch(url.toString())\n\n    if (response.status >= 400) {\n      const error = (await response.json()) as ApiError\n      throw new Error(`${error.code}: ${error.error}`)\n    }\n\n    return response.json() as Promise<Output>\n  }\n\n/** All endpoints, untyped. */\nexport const endpoints = {\n  // GIF endpoints\n  gifs: endpoint('gifs'),\n  search: endpoint('search'),\n  trending: endpoint('trending'),\n  random: endpoint('random'),\n  // Textual endpoints\n  searchSuggestions: endpoint('search_suggestions'),\n  autocomplete: endpoint('autocomplete'),\n  trendingTerms: endpoint('trending_terms'),\n  // Other endpoints\n  categories: endpoint('categories'),\n  registerShare: endpoint('registershare'),\n  anonid: endpoint('anonid'),\n}\n\n/** Searches for GIFs. */\nexport async function search(\n  options: CommonSearchOptions\n): Promise<CommonResults>\nexport async function search(\n  options: CommonSearchOptions & {\n    /** Reduces the list of GIFs returned to tinygif, gif, and mp4. */\n    media_filter: 'minimal'\n  }\n): Promise<MinimalResults>\nexport async function search(\n  options: CommonSearchOptions & {\n    /**\n     * Reduces the list of GIFs returned to nanomp4, tinygif, tinymp4, gif, mp4,\n     * and nanogif.\n     */\n    media_filter: 'basic'\n  }\n): Promise<BasicResults>\nexport async function search(options: unknown): Promise<unknown> {\n  return endpoints.search(options)\n}\n\n/** Gets the current global trending GIFs. */\nexport async function trending(options: CommonOptions): Promise<CommonResults>\nexport async function trending(\n  options: CommonOptions & {\n    /** Reduces the list of GIFs returned to tinygif, gif, and mp4. */\n    media_filter: 'minimal'\n  }\n): Promise<MinimalResults>\nexport async function trending(\n  options: CommonOptions & {\n    /**\n     * Reduces the list of GIFs returned to nanomp4, tinygif, tinymp4, gif, mp4,\n     * and nanogif.\n     */\n    media_filter: 'basic'\n  }\n): Promise<BasicResults>\nexport async function trending(options: unknown): Promise<unknown> {\n  return endpoints.trending(options)\n}\n\n/** Gets a list of GIF categories. */\nexport async function categories(options: {\n  key: string\n  locale?: string\n  type?: 'featured' | 'trending'\n  contentfilter?: 'off' | 'low' | 'medium' | 'high'\n  anon_id?: string\n}): Promise<{\n  tags: Array<{\n    /** The search term that corresponds to the category. */\n    searchterm: string\n    /** The search url to request if the user selects the category. */\n    path: string\n    /** A url to the media source for the category's example GIF. */\n    image: string\n    /**\n     * Category name to overlay over the image. The name will be translated to\n     * match the locale of the corresponding request.\n     */\n    name: string\n  }>\n}>\nexport async function categories(options: {\n  key: string\n  locale?: string\n  type: 'emoji'\n  contentfilter?: 'off' | 'low' | 'medium' | 'high'\n  anon_id?: string\n}): Promise<{\n  tags: Array<{\n    /** The search term that corresponds to the category. */\n    searchterm: string\n    /** The search url to request if the user selects the category. */\n    path: string\n    /**\n     * Category name to overlay over the image. The name will be translated to\n     * match the locale of the corresponding request.\n     */\n    name: string\n    /** Emoji. */\n    character: string\n  }>\n}>\nexport async function categories(options: unknown): Promise<unknown> {\n  return endpoints.categories(options)\n}\n\n/** Gets related search terms to find a more precise GIF. */\nexport async function searchSuggestions(options: {\n  key: string\n  q: string\n  locale?: string\n  limit?: number\n  anon_id?: string\n}): Promise<{ results: string[] }>\nexport async function searchSuggestions(options: unknown): Promise<unknown> {\n  return endpoints.searchSuggestions(options)\n}\n\n/** Gets a list of completed search terms given a partial search term. */\nexport async function autocomplete(options: {\n  key: string\n  q: string\n  locale?: string\n  limit?: number\n  anon_id?: string\n}): Promise<{ results: string[] }>\nexport async function autocomplete(options: unknown): Promise<unknown> {\n  return endpoints.autocomplete(options)\n}\n\n/** Gets current trending search terms. */\nexport async function trendingTerms(options: {\n  key: string\n  locale?: string\n  limit?: number\n  anon_id?: string\n}): Promise<{ results: string[] }>\nexport async function trendingTerms(options: unknown): Promise<unknown> {\n  return endpoints.trendingTerms(options)\n}\n\n/** Registers a user’s sharing of a GIF. */\nexport async function registerShare(options: {\n  key: string\n  id: string\n  locale?: string\n  q?: string\n  anon_id?: string\n}): Promise<{ status: 'ok' }>\nexport async function registerShare(options: unknown): Promise<unknown> {\n  return endpoints.registerShare(options)\n}\n\nexport type GifDetailsOptions = {\n  /** Comma separated list of GIF identifiers. */\n  ids: string\n  key: string\n  limit?: number\n  pos?: string\n  anon_id?: string\n}\n\n/** Gets details about the GIFs given. */\nexport async function gifs(options: GifDetailsOptions): Promise<CommonResults>\nexport async function gifs(\n  options: GifDetailsOptions & { media_filter: 'basic' }\n): Promise<BasicResults>\nexport async function gifs(\n  options: GifDetailsOptions & { media_filter: 'minimal' }\n): Promise<MinimalResults>\nexport async function gifs(options: unknown): Promise<unknown> {\n  return endpoints.gifs(options)\n}\n\n/** Searches for GIFs, but does not rank them by popularity. */\nexport async function random(\n  options: CommonSearchOptions\n): Promise<CommonResults>\nexport async function random(\n  options: CommonSearchOptions & {\n    /** Reduces the list of GIFs returned to tinygif, gif, and mp4. */\n    media_filter: 'minimal'\n  }\n): Promise<MinimalResults>\nexport async function random(\n  options: CommonSearchOptions & {\n    /**\n     * Reduces the list of GIFs returned to nanomp4, tinygif, tinymp4, gif, mp4,\n     * and nanogif.\n     */\n    media_filter: 'basic'\n  }\n): Promise<BasicResults>\nexport async function random(options: unknown): Promise<unknown> {\n  return endpoints.random(options)\n}\n\n/**\n * Creates an anonymous id.\n *\n * @remarks\n *   This API requires custom development from Tenor.\n */\nexport async function anonId(options: {\n  key: string\n}): Promise<{ anon_id: string }>\nexport async function anonId(options: unknown): Promise<unknown> {\n  return endpoints.anonid(options)\n}\n","/**\n * A Tenor API with better naming conventions.\n *\n * @module\n */\nimport type { BasicResults } from './raw-api'\nimport {\n  autocomplete as rawAutocomplete,\n  categories as rawCategories,\n  gifs as rawGifs,\n  random as rawRandom,\n  registerShare as rawRegisterShare,\n  search as rawSearch,\n  searchSuggestions as rawSearchSuggestions,\n  trending as rawTrending,\n  trendingTerms as rawTrendingTerms,\n} from './raw-api'\n\n/** Represents a GIF object. */\nexport interface Gif {\n  /** Tenor GIF id. */\n  id: string\n  /** GIF description. */\n  description: string\n  /** GIF width. */\n  width: number\n  /** GIF height. */\n  height: number\n  /** Image URL. */\n  gif: string\n}\n\nexport interface CommonOptions {\n  /** Tenor API key. You may use `LIVDSRZULELA` for testing. */\n  key: string\n  /**\n   * Search term locale, formatted as `language_COUNTRY`.\n   *\n   * @default `en_US`\n   */\n  locale?: string\n  /**\n   * Safety filter:\n   *\n   * - `off` - G, PG, PG-13, and R (no nudity)\n   * - `low` - G, PG, and PG-13\n   * - `medium` - G and PG\n   * - `high` - G\n   *\n   * @default `off`\n   * @see https://tenor.com/gifapi/documentation#contentfilter\n   */\n  safety?: 'off' | 'low' | 'medium' | 'high'\n  /**\n   * Aspect ratio filter:\n   *\n   * - `all` - no constraints\n   * - `wide` - 0.42 <= aspect ratio <= 2.36\n   * - `standard` - 0.56 <= aspect ratio <= 1.78\n   *\n   * @default `all`\n   */\n  ratio?: 'all' | 'wide' | 'standard'\n  /**\n   * Video quality filter. Medium is sufficient for most purposes, even on\n   * desktop and hdpi devices.\n   *\n   * @default `medium`\n   */\n  quality?: 'low' | 'medium' | 'high'\n  /**\n   * Number of results per page. (max: 50)\n   *\n   * @default 20\n   */\n  limit?: number\n  /** Page id, given by the `next` field of the result. */\n  page?: string\n}\n\nexport type GifDetailsOptions = {\n  key: string\n  /** Array of GIF ids. */\n  ids: string[]\n  quality?: 'low' | 'medium' | 'high'\n  limit?: number\n  page?: string\n}\n\nexport interface SearchOptions extends CommonOptions {\n  /** Search term. */\n  q: string\n}\n\nexport interface ResultPage {\n  /** GIFs. Yep. */\n  results: Gif[]\n  /** Next page id. */\n  next: string\n}\n\nexport interface SuggestionOptions {\n  /** Tenor API key. You may use `LIVDSRZULELA` for testing. */\n  key: string\n  /** Search term. */\n  q: string\n  /**\n   * Search term locale, formatted as `language_COUNTRY`.\n   *\n   * @default `en_US`\n   */\n  locale?: string\n  /**\n   * Number of results. (max: 50)\n   *\n   * @default 10\n   */\n  limit?: number\n}\n\n/** Transforms a `raw-api` response into a friendlier object. */\nconst formatResponse = (\n  { results, next }: BasicResults,\n  quality: 'low' | 'medium' | 'high' = 'medium'\n): ResultPage => ({\n  results: results.map(({ id, title, content_description, media }) => {\n    const prefix = ({ low: 'nano', medium: 'tiny', high: '' } as const)[quality]\n    return {\n      id,\n      description: title.length > 0 ? title : content_description,\n      width: media[0][`${prefix}gif`].dims[0],\n      height: media[0][`${prefix}gif`].dims[1],\n      gif: media[0][`${prefix}gif`].url,\n    }\n  }),\n  next,\n})\n\n/** Gets details about one or several GIFs. */\nexport const gifDetails = async ({\n  key,\n  ids,\n  quality,\n  limit,\n  page,\n}: GifDetailsOptions): Promise<ResultPage> =>\n  formatResponse(\n    await rawGifs({\n      key,\n      ids: ids.join(','),\n      limit,\n      pos: page,\n      media_filter: 'basic',\n    }),\n    quality\n  )\n\n/** Searches for GIFs. */\nexport const search = async ({\n  key,\n  q,\n  locale,\n  quality,\n  safety,\n  ratio,\n  limit,\n  page,\n}: SearchOptions): Promise<ResultPage> =>\n  formatResponse(\n    await rawSearch({\n      key,\n      q,\n      locale,\n      contentfilter: safety,\n      ar_range: ratio,\n      limit,\n      pos: page,\n      media_filter: 'basic',\n    }),\n    quality\n  )\n\n/** Searches for GIFs, but shuffles the result. */\nexport const shuffledSearch = async ({\n  key,\n  q,\n  locale,\n  quality,\n  safety,\n  ratio,\n  limit,\n  page,\n}: SearchOptions): Promise<ResultPage> =>\n  formatResponse(\n    await rawRandom({\n      key,\n      q,\n      locale,\n      contentfilter: safety,\n      ar_range: ratio,\n      limit,\n      pos: page,\n      media_filter: 'basic',\n    }),\n    quality\n  )\n\n/** Fetches trending GIFs. */\nexport const trending = async ({\n  key,\n  locale,\n  quality,\n  safety,\n  ratio,\n  limit,\n  page,\n}: CommonOptions): Promise<ResultPage> =>\n  formatResponse(\n    await rawTrending({\n      key,\n      locale,\n      contentfilter: safety,\n      ar_range: ratio,\n      limit,\n      pos: page,\n      media_filter: 'basic',\n    }),\n    quality\n  )\n\n/** Registers a user’s sharing of a GIF. */\nexport const registerShare = async (options: {\n  key: string\n  id: string\n  locale?: string\n  q?: string\n}): Promise<{ status: 'ok' }> => rawRegisterShare(options)\n\n/** Completes the user's search. */\nexport const autocomplete = async ({\n  key,\n  q,\n  locale,\n  limit,\n}: SuggestionOptions): Promise<string[]> =>\n  (await rawAutocomplete({ key, q, locale, limit })).results\n\n/** Returns related search terms. */\nexport const related = async ({\n  key,\n  q,\n  locale,\n  limit,\n}: SuggestionOptions): Promise<string[]> =>\n  (await rawSearchSuggestions({ key, q, locale, limit })).results\n\n/** Returns trending search terms. */\nexport const trendingTerms = async ({\n  key,\n  locale,\n  limit,\n}: {\n  key: string\n  locale?: string\n  limit?: number\n}) => (await rawTrendingTerms({ key, locale, limit })).results\n\n/** Returns Tenor GIF categories. */\nexport const categories = async ({\n  key,\n  type,\n  locale,\n  safety,\n}: {\n  key: string\n  type?: 'featured' | 'trending'\n  locale?: string\n  safety?: 'off' | 'low' | 'medium' | 'high'\n}) =>\n  (await rawCategories({ key, type, locale, contentfilter: safety })).tags.map(\n    ({ searchterm, image }) => ({ term: searchterm, gif: image })\n  )\n","<script lang=\"ts\">\n  import { createEventDispatcher } from 'svelte'\n  import { flip } from 'svelte/animate'\n  import { fade } from 'svelte/transition'\n\n  export let terms: string[]\n  export let scroll = false\n\n  const dispatch = createEventDispatcher<{ click: string }>()\n\n  const color = (str: string) => {\n    let hash = 0xc0ffee\n    for (const char of str) hash = ((hash << 5) - hash + char.charCodeAt(0)) | 0\n    const red = ((hash & 0xff0000) >> 16) + 1\n    const green = ((hash & 0x00ff00) >> 8) + 1\n    const blue = (hash & 0x0000ff) + 1\n    const l = 0.4 * red + 0.4 * green + 0.2 * blue\n    const h = (n: number) =>\n      Math.min(0xd0, Math.max(0x60, Math.floor((n * 0xd0) / l)))\n        .toString(16)\n        .padStart(2, '0')\n    return `#${h(red)}${h(green)}${h(blue)}`\n  }\n</script>\n\n<div class=\"terms\" class:scroll>\n  {#each terms as term (term)}\n    <button\n      style:background-color={color(term)}\n      on:click={() => {\n        dispatch('click', term)\n      }}\n      animate:flip={{ duration: 100 }}\n      transition:fade={{ duration: 100 }}\n    >\n      {term}\n    </button>\n  {/each}\n</div>\n\n<style lang=\"scss\">\n  .terms {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 0.5em;\n\n    &.scroll {\n      flex-wrap: nowrap;\n      overflow: auto;\n    }\n  }\n\n  button {\n    flex-shrink: 0;\n    padding: 0.5em;\n    font-weight: bold;\n    color: white;\n    text-shadow: 0 0 0.25em #0008;\n    border: 0;\n    border-radius: 0.25em;\n    box-shadow: 0 0 0.25em #8884;\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { SuggestionOptions } from './api'\n  import { autocomplete } from './api'\n  import Terms from './Terms.svelte'\n\n  /** Tenor API key. */\n  export let key: SuggestionOptions['key']\n  /** Search term. */\n  export let q: SuggestionOptions['q']\n  /** Search locale. */\n  export let locale: SuggestionOptions['locale'] = undefined\n  /** Number of results. */\n  export let limit: SuggestionOptions['limit'] = undefined\n\n  /** Keeps the buttons on one line instead of wrapping. */\n  export let scroll = false\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * Terms displayed.\n   *\n   * @readonly\n   */\n  export let terms: string[] | undefined = undefined\n\n  /** Latest request performed. */\n  let latestRequest: Promise<string[]> | undefined\n\n  const dispatch = createEventDispatcher<{ error: Error }>()\n\n  /** Fetches suggestions. */\n  const update = async () => {\n    loading = true\n    let localRequest = autocomplete({ key, q, locale, limit })\n    latestRequest = localRequest\n    let results = await localRequest\n    // If the current search is not the latest one\n    // (the change term changed in between), ignore the result\n    if (latestRequest !== localRequest) return\n    terms = results\n    loading = false\n  }\n\n  $: if (mounted || retry) {\n    q\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      terms = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(() => {\n    mounted = true\n  })\n</script>\n\n{#if terms !== undefined}\n  <Terms {terms} {scroll} on:click />\n{/if}\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import Autocomplete from '../lib/Autocomplete.svelte'\n\n  let q = ''\n</script>\n\n<Meta\n  title=\"Components/Autocomplete\"\n  component={Autocomplete}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 10,\n    },\n    scroll: { control: { type: 'boolean' }, defaultValue: false },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"autocomplete\" name=\"Autocomplete\" let:args>\n  <div class=\"row\">\n    <input type=\"text\" bind:value={q} />\n    <Autocomplete\n      {...args}\n      {q}\n      on:click={({ detail }) => {\n        args.onClick(detail)\n        q = detail\n      }}\n      on:error={({ detail }) => {\n        args.onError(detail)\n      }}\n    />\n  </div>\n</Story>\n\n<style>\n  .row {\n    display: flex;\n    gap: 0.5em;\n    align-items: flex-start;\n  }\n\n  input {\n    padding: 0.25em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { SearchOptions } from './api'\n  import { categories as categoriesApi } from './api'\n\n  /** Tenor API key. */\n  export let key: SearchOptions['key']\n  /**\n   * Category.\n   *\n   * @default `featured`\n   */\n  export let type: 'featured' | 'trending' | undefined = undefined\n  /** Search locale. */\n  export let locale: SearchOptions['locale'] = undefined\n  /** Safety filter. */\n  export let safety: SearchOptions['safety'] = undefined\n\n  /**\n   * Minimum column size, in pixels.\n   *\n   * @default 140\n   */\n  export let columnSize = 140\n  /**\n   * Gap between GIFs, in pixels.\n   *\n   * @default 8px\n   */\n  export let gap = 8\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /** @readonly */\n  export let categories: Array<{ term: string; gif: string }> | undefined =\n    undefined\n\n  const dispatch = createEventDispatcher<{ click: string; error: Error }>()\n\n  const update = async () => {\n    categories = await categoriesApi({ key, type, locale, safety })\n    loading = false\n  }\n\n  $: if (mounted || retry) {\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      categories = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(async () => {\n    mounted = true\n  })\n</script>\n\n{#if categories !== undefined}\n  <div class=\"categories\" style:--column=\"{columnSize}px\" style:--gap=\"{gap}px\">\n    {#each categories as { term, gif }}\n      <button\n        style:background-image=\"linear-gradient(to bottom, #0003, #0004, #0008),\n        url({gif})\"\n        on:click={() => dispatch('click', term)}\n      >\n        {term}\n      </button>\n    {/each}\n  </div>\n{/if}\n\n<style>\n  .categories {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(var(--column, 200px), 1fr));\n    gap: var(--gap, 8px);\n  }\n\n  button {\n    padding: 3em 1em;\n    font-weight: bold;\n    color: #fff;\n    text-shadow: 0 0 0.25em #000;\n    background-color: #8888;\n    background-position: center;\n    background-size: cover;\n    border: 0;\n    border-radius: 0.25em;\n  }\n</style>\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import Categories from '../lib/Categories.svelte'\n</script>\n\n<Meta\n  title=\"Components/Categories\"\n  component={Categories}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    type: {\n      options: ['featured', 'trending'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'featured',\n    },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    safety: {\n      options: ['off', 'low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'off',\n    },\n    columnSize: {\n      control: { type: 'range', min: 10, max: 360, step: 1 },\n      defaultValue: 140,\n    },\n    gap: {\n      control: { type: 'range', min: 0, max: 20, step: 1 },\n      defaultValue: 8,\n    },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"categories\" name=\"Categories\" let:args>\n  <Categories\n    {...args}\n    on:click={({ detail }) => args.onClick(detail)}\n    on:error={({ detail }) => args.onError(detail)}\n  />\n</Story>\n","<script lang=\"ts\">\n  import type { Gif } from './api'\n\n  export let gif: Gif\n\n  $: ({ description, width, height, gif: src } = gif)\n</script>\n\n<img {src} alt={description} {width} {height} class=\"gif\" />\n\n<style lang=\"scss\">\n  img {\n    width: auto;\n    max-width: 100%;\n    height: auto;\n    max-height: 100%;\n    vertical-align: bottom;\n    background: linear-gradient(to right, purple, tomato);\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher } from 'svelte'\n  import type { Gif } from './api'\n  import GifComponent from './Gif.svelte'\n\n  /**\n   * Minimum size for each column, in pixels. The maximum size is `columnSize * 2 + gap`.\n   *\n   * @default 160px\n   */\n  export let columnSize = 160\n\n  const defaultRowSize = 8\n  /**\n   * Size of each row. A GIF spans over multiple grid rows.\n   *\n   * @default 8px\n   */\n  let rowSize = defaultRowSize\n\n  /**\n   * Gap between GIFs, in pixels.\n   *\n   * @default 8px\n   */\n  export let gap = 8\n\n  /**\n   * In-line, horizontal scrolling grid.\n   *\n   * @default false\n   */\n  export let inline = false\n\n  /** Array of GIFs to display. */\n  export let gifs: Gif[] = []\n\n  const dispatch = createEventDispatcher<{ click: Gif }>()\n\n  /** Preserves the aspect ratio of the GIFs. */\n  const watch = (el: HTMLElement) => {\n    // To avoid a bug, we keep the last two widths\n    let widths = [-1, -1]\n    const observer = new ResizeObserver(() => {\n      // If we are oscillating between two widths, abort\n      if (el.offsetWidth === widths[0]) return\n      widths = [widths[1], el.offsetWidth]\n      const columns = window\n        .getComputedStyle(el)\n        .getPropertyValue('grid-template-columns')\n        .split(' ').length\n      const available = el.offsetWidth - (columns - 1) * gap\n      // Compute the row size to keep the aspect ratio\n      rowSize =\n        ((available / columns) * (defaultRowSize + gap)) / columnSize - gap\n    })\n    observer.observe(el)\n\n    return {\n      destroy() {\n        observer.unobserve(el)\n      },\n    }\n  }\n</script>\n\n<div\n  class=\"grid\"\n  class:inline\n  style:--column=\"{columnSize}px\"\n  style:--row=\"{rowSize}px\"\n  style:--gap=\"{gap}px\"\n  use:watch\n>\n  {#each gifs as gif (gif.id)}\n    <button\n      style:grid-row-end=\"span {Math.ceil(\n        (columnSize * gif.height) / gif.width / (defaultRowSize + gap)\n      )}\"\n      type=\"button\"\n      on:click={() => dispatch('click', gif)}\n    >\n      <GifComponent {gif} />\n    </button>\n  {/each}\n</div>\n\n<style lang=\"scss\">\n  .grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(var(--column, 160px), 1fr));\n    grid-auto-rows: var(--row, 8px);\n    gap: var(--gap, 8px);\n    align-items: stretch;\n    border-radius: 4px;\n\n    &.inline {\n      display: flex;\n      height: var(--column, 160px);\n      overflow: auto;\n    }\n  }\n\n  button {\n    position: relative;\n    flex-shrink: 0;\n    padding: 0;\n    margin: 0;\n    overflow: hidden;\n    background: none;\n    border: 0;\n    border-radius: 4px;\n\n    &::before {\n      position: absolute;\n      inset: 0;\n      content: '';\n      transition: 0.2s box-shadow;\n    }\n\n    &:focus,\n    &:active {\n      outline: 0;\n\n      &::before {\n        box-shadow: 0 0 1em blue inset, 0 0 1em white inset;\n      }\n    }\n\n    > :global(.gif) {\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { Gif, ResultPage, SearchOptions } from './api'\n  import { search } from './api'\n  import Grid from './Grid.svelte'\n\n  /** Tenor API key. */\n  export let key: SearchOptions['key']\n  /** Search term. */\n  export let q: SearchOptions['q']\n  /** Search locale. */\n  export let locale: SearchOptions['locale'] = undefined\n  /** Video quality filter. */\n  export let quality: SearchOptions['quality'] = undefined\n  /** Safety filter. */\n  export let safety: SearchOptions['safety'] = undefined\n  /** Aspect ratio filter. */\n  export let ratio: SearchOptions['ratio'] = undefined\n  /** Number of results per page. */\n  export let limit: SearchOptions['limit'] = undefined\n\n  /** Number of pages to display. */\n  export let page = 1\n\n  /** Minimum size for each column, in pixels. The maximum size is `columnSize * 2 + gap`. */\n  export let columnSize: number | undefined = undefined\n  /** Gap between GIFs, in pixels. */\n  export let gap: number | undefined = undefined\n  /** In-line, horizontal scrolling grid. */\n  export let inline: boolean | undefined = undefined\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * GIFs displayed in the grid.\n   *\n   * @readonly\n   */\n  export let gifs: Array<Gif> | undefined = undefined\n\n  /** Latest request performed. */\n  let latestRequest: Promise<ResultPage> | undefined\n\n  /** Pages loaded and cached. */\n  let pages: Array<ResultPage> = []\n\n  const dispatch = createEventDispatcher<{ error: Error }>()\n\n  /** Performs a search when the search term or the number of pages changes. */\n  const update = async () => {\n    while (pages.length < page) {\n      loading = true\n      let localRequest = search({\n        key,\n        q,\n        locale,\n        quality,\n        safety,\n        ratio,\n        limit,\n        page: pages[pages.length - 1]?.next,\n      })\n      latestRequest = localRequest\n      // Wait for the search to finish\n      let page = await localRequest\n      // If the current search is not the latest one\n      // (the change term changed in between), ignore the result\n      if (latestRequest !== localRequest) return\n      // Otherwise, add the page at the end of the cache\n      pages = [...pages, page]\n    }\n    // Update the grid\n    gifs = pages.slice(0, page).flatMap(({ results }) => results)\n    loading = false\n  }\n\n  // Reset the number of pages and the cache when the search term changes\n  $: {\n    q\n    page = 1\n    pages = []\n  }\n\n  // Perform a search when the search term or the number of pages changes\n  $: if (mounted || retry) {\n    q\n    page\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      gifs = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(() => {\n    mounted = true\n  })\n</script>\n\n{#if gifs !== undefined}\n  <Grid {gifs} {columnSize} {gap} {inline} on:click />\n{/if}\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { Gif, SearchOptions } from './api'\n  import { registerShare } from './api'\n  import Search from './Search.svelte'\n\n  /** Tenor API key. */\n  export let key: SearchOptions['key']\n  /** Search term. */\n  export let q: SearchOptions['q'] = ''\n  /** Search locale. */\n  export let locale: SearchOptions['locale'] = undefined\n  /** Video quality filter. */\n  export let quality: SearchOptions['quality'] = undefined\n  /** Safety filter. */\n  export let safety: SearchOptions['safety'] = undefined\n  /** Aspect ratio filter. */\n  export let ratio: SearchOptions['ratio'] = undefined\n  /** Number of results per page. */\n  export let limit: SearchOptions['limit'] = undefined\n\n  /** Number of pages to display. */\n  export let page = 1\n\n  /**\n   * Minimum size for each column, in pixels. The maximum size is `columnSize * 2 + gap`.\n   *\n   * @default 140px\n   */\n  export let columnSize = 140\n  /**\n   * Gap between elements, in pixels.\n   *\n   * @default 4px\n   */\n  export let gap = 4\n  /**\n   * Should the input be focused when mounted?\n   *\n   * @default true\n   */\n  export let autofocus = true\n  /** Keyboard messages. */\n  export let messages: {\n    /** Text displayed in the search field when empty. */\n    placeholder: string\n    /** Text in the Close button. Set to `false` to hide the button. */\n    close: string | false\n    /**\n     * What error should be displayed?\n     *\n     * - `false`: No error at all\n     * - `true`: Original error message\n     * - `string`: Custom error message\n     */\n    error: string | boolean\n    /** Text in the Retry button. Set to `false` to hide the button. */\n    retry: string | false\n  } = {\n    placeholder: 'Search Tenor',\n    close: 'Close',\n    error: 'Tenor is currently unavailable',\n    retry: 'Retry',\n  }\n\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * GIFs displayed in the grid.\n   *\n   * @readonly\n   */\n  export let gifs: Array<Gif> | undefined = undefined\n\n  // Handle errors and retries\n  let error: Error | undefined\n  let retry = false\n\n  const dispatch = createEventDispatcher<{ click: Gif; close: void }>()\n\n  let input: HTMLInputElement | undefined\n  onMount(() => {\n    if (input && autofocus) input.focus()\n  })\n</script>\n\n<div\n  class=\"mobile-keyboard\"\n  style:--column=\"{columnSize}px\"\n  style:--gap=\"{gap}px\"\n>\n  {#if gifs === undefined}\n    {#if error !== undefined}\n      <div class=\"placeholder\">\n        {#if messages.error === true}\n          {error.message}\n        {:else if messages.error !== false}\n          {messages.error}\n        {/if}\n        {#if messages.retry !== false}\n          <button\n            type=\"button\"\n            on:click={() => {\n              error = undefined\n              retry = true\n            }}\n          >\n            {messages.retry}\n          </button>\n        {/if}\n      </div>\n    {:else}\n      <div class=\"placeholder\">\n        <div class=\"spinner\" aria-label=\"Loading\" />\n      </div>\n    {/if}\n  {/if}\n  <Search\n    {key}\n    {q}\n    {locale}\n    {quality}\n    {safety}\n    {ratio}\n    {limit}\n    {columnSize}\n    {gap}\n    inline={true}\n    bind:page\n    bind:loading\n    bind:gifs\n    bind:retry\n    on:click={({ detail }) => {\n      dispatch('click', detail)\n      void registerShare({ key, id: detail.id, q, locale })\n    }}\n    on:error={({ detail }) => {\n      error = detail\n    }}\n  />\n  <div class=\"row\">\n    {#if messages.close !== false}\n      <button\n        type=\"button\"\n        on:click={() => {\n          dispatch('close')\n        }}\n      >\n        {messages.close}\n      </button>\n    {/if}\n    <input\n      type=\"search\"\n      placeholder={messages.placeholder}\n      bind:value={q}\n      bind:this={input}\n    />\n  </div>\n</div>\n\n<style lang=\"scss\">\n  .mobile-keyboard {\n    display: flex;\n    flex-direction: column;\n    gap: var(--gap, 4px);\n    max-height: 100%;\n  }\n\n  .placeholder {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5em;\n    align-items: center;\n    justify-content: center;\n    height: var(--column, 140px);\n  }\n\n  .spinner {\n    width: 2em;\n    height: 2em;\n    background-image: linear-gradient(to right, purple, tomato);\n    border-radius: 0.5em;\n    animation: spin 2s infinite cubic-bezier(0.6, -0.5, 0.3, 1.8);\n  }\n\n  .row {\n    display: flex;\n    gap: var(--gap, 4px);\n\n    > input {\n      flex: 1;\n    }\n  }\n\n  @keyframes spin {\n    100% {\n      transform: rotate(720deg);\n    }\n  }\n</style>\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import MobileKeyboard from '../lib/MobileKeyboard.svelte'\n</script>\n\n<Meta\n  title=\"Keyboards/MobileKeyboard\"\n  component={MobileKeyboard}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    quality: {\n      options: ['low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'medium',\n    },\n    safety: {\n      options: ['off', 'low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'off',\n    },\n    ratio: {\n      options: ['all', 'wide', 'standard'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'all',\n    },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 20,\n    },\n    columnSize: {\n      control: { type: 'range', min: 10, max: 360, step: 1 },\n      defaultValue: 140,\n    },\n    gap: {\n      control: { type: 'range', min: 0, max: 20, step: 1 },\n      defaultValue: 4,\n    },\n    autofocus: {\n      control: { type: 'boolean' },\n      defaultValue: true,\n    },\n    messages: {\n      control: { type: 'object' },\n      defaultValue: {\n        placeholder: 'Search Tenor',\n        close: 'Close',\n        error: 'Tenor is currently unavailable',\n        retry: 'Retry',\n      },\n    },\n    onClick: { action: {} },\n    onClose: { action: {} },\n  }}\n/>\n\n<Story id=\"mobilekeyboard\" name=\"MobileKeyboard\" let:args>\n  <MobileKeyboard\n    {...args}\n    on:click={({ detail }) => args.onClick(detail)}\n    on:close={() => args.onClick()}\n  />\n</Story>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { SuggestionOptions } from './api'\n  import { related } from './api'\n  import Terms from './Terms.svelte'\n\n  /** Tenor API key. */\n  export let key: SuggestionOptions['key']\n  /** Search term. */\n  export let q: SuggestionOptions['q']\n  /** Search locale. */\n  export let locale: SuggestionOptions['locale'] = undefined\n  /** Number of results. */\n  export let limit: SuggestionOptions['limit'] = undefined\n\n  /** Keeps the buttons on one line instead of wrapping. */\n  export let scroll = false\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * Terms displayed.\n   *\n   * @readonly\n   */\n  export let terms: string[] | undefined = undefined\n\n  /** Latest request performed. */\n  let latestRequest: Promise<string[]> | undefined\n\n  const dispatch = createEventDispatcher<{ error: Error }>()\n\n  /** Fetches suggestions. */\n  const update = async () => {\n    loading = true\n    let localRequest = related({ key, q, locale, limit })\n    latestRequest = localRequest\n    let results = await localRequest\n    // If the current search is not the latest one\n    // (the change term changed in between), ignore the result\n    if (latestRequest !== localRequest) return\n    terms = results\n    loading = false\n  }\n\n  $: if (mounted || retry) {\n    q\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      terms = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(() => {\n    mounted = true\n  })\n</script>\n\n{#if terms !== undefined}\n  <Terms {terms} {scroll} on:click />\n{/if}\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import Related from '../lib/Related.svelte'\n\n  let q = ''\n</script>\n\n<Meta\n  title=\"Components/Related\"\n  component={Related}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 10,\n    },\n    scroll: { control: { type: 'boolean' }, defaultValue: false },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"related\" name=\"Related\" let:args>\n  <div class=\"row\">\n    <input type=\"text\" bind:value={q} />\n    <Related\n      {...args}\n      {q}\n      on:click={({ detail }) => {\n        args.onClick(detail)\n        q = detail\n      }}\n      on:error={({ detail }) => args.onError(detail)}\n    />\n  </div>\n</Story>\n\n<style>\n  .row {\n    display: flex;\n    gap: 0.5em;\n    align-items: flex-start;\n  }\n\n  input {\n    padding: 0.25em;\n  }\n</style>\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import Search from '../lib/Search.svelte'\n\n  let q = 'hello'\n  let page = 1\n  let loading = false\n</script>\n\n<Meta\n  title=\"Components/Search\"\n  component={Search}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    quality: {\n      options: ['low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'medium',\n    },\n    safety: {\n      options: ['off', 'low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'off',\n    },\n    ratio: {\n      options: ['all', 'wide', 'standard'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'all',\n    },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 20,\n    },\n    columnSize: {\n      control: { type: 'range', min: 10, max: 360, step: 1 },\n      defaultValue: 160,\n    },\n    gap: {\n      control: { type: 'range', min: 0, max: 20, step: 1 },\n      defaultValue: 8,\n    },\n    inline: {\n      control: { type: 'boolean' },\n      defaultValue: false,\n    },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"search\" name=\"Search\" let:args>\n  <p class=\"form\"><input type=\"text\" bind:value={q} /></p>\n  <Search\n    {...args}\n    {q}\n    {page}\n    bind:loading\n    on:click={({ detail }) => args.onClick(detail)}\n    on:error={({ detail }) => args.onError(detail)}\n  />\n  <p class=\"more\">\n    <button on:click={() => page++} disabled={loading}>Load more</button>\n  </p>\n</Story>\n\n<style>\n  .form {\n    display: flex;\n  }\n\n  .form > input {\n    flex: 1;\n    padding: 0.25em;\n  }\n\n  .more {\n    text-align: center;\n  }\n\n  .more > button {\n    padding: 1em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { Gif, ResultPage, SearchOptions } from './api'\n  import { shuffledSearch } from './api'\n  import Grid from './Grid.svelte'\n\n  /** Tenor API key. */\n  export let key: SearchOptions['key']\n  /** Search term. */\n  export let q: SearchOptions['q']\n  /** Search locale. */\n  export let locale: SearchOptions['locale'] = undefined\n  /** Video quality filter. */\n  export let quality: SearchOptions['quality'] = undefined\n  /** Safety filter. */\n  export let safety: SearchOptions['safety'] = undefined\n  /** Aspect ratio filter. */\n  export let ratio: SearchOptions['ratio'] = undefined\n  /** Number of results per page. */\n  export let limit: SearchOptions['limit'] = undefined\n\n  /** Number of pages to display. */\n  export let page = 1\n\n  /** Minimum size for each column, in pixels. The maximum size is `columnSize * 2 + gap`. */\n  export let columnSize: number | undefined = undefined\n  /** Gap between GIFs, in pixels. */\n  export let gap: number | undefined = undefined\n  /** In-line, horizontal scrolling grid. */\n  export let inline: boolean | undefined = undefined\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * GIFs displayed in the grid.\n   *\n   * @readonly\n   */\n  export let gifs: Array<Gif> | undefined = undefined\n\n  /** Latest request performed. */\n  let latestRequest: Promise<ResultPage> | undefined\n\n  /** Pages loaded and cached. */\n  let pages: Array<ResultPage> = []\n\n  const dispatch = createEventDispatcher<{ error: Error }>()\n\n  /** Performs a search when the search term or the number of pages changes. */\n  const update = async () => {\n    while (pages.length < page) {\n      loading = true\n      let localRequest = shuffledSearch({\n        key,\n        q,\n        locale,\n        quality,\n        safety,\n        ratio,\n        limit,\n        page: pages[pages.length - 1]?.next,\n      })\n      latestRequest = localRequest\n      // Wait for the search to finish\n      let page = await localRequest\n      // If the current search is not the latest one\n      // (the change term changed in between), ignore the result\n      if (latestRequest !== localRequest) return\n      // Otherwise, add the page at the end of the cache\n      pages = [...pages, page]\n    }\n    // Update the grid\n    gifs = pages.slice(0, page).flatMap(({ results }) => results)\n    loading = false\n  }\n\n  // Reset the number of pages and the cache when the search term changes\n  $: {\n    q\n    page = 1\n    pages = []\n  }\n\n  // Perform a search when the search term or the number of pages changes\n  $: if (mounted || retry) {\n    q\n    page\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      gifs = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(() => {\n    mounted = true\n  })\n</script>\n\n{#if gifs !== undefined}\n  <Grid {gifs} {columnSize} {gap} {inline} on:click />\n{/if}\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import ShuffledSearch from '../lib/ShuffledSearch.svelte'\n\n  let q = 'hello'\n  let page = 1\n  let loading = false\n</script>\n\n<Meta\n  title=\"Components/ShuffledSearch\"\n  component={ShuffledSearch}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    quality: {\n      options: ['low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'medium',\n    },\n    safety: {\n      options: ['off', 'low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'off',\n    },\n    ratio: {\n      options: ['all', 'wide', 'standard'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'all',\n    },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 20,\n    },\n    columnSize: {\n      control: { type: 'range', min: 10, max: 360, step: 1 },\n      defaultValue: 160,\n    },\n    gap: {\n      control: { type: 'range', min: 0, max: 20, step: 1 },\n      defaultValue: 8,\n    },\n    inline: {\n      control: { type: 'boolean' },\n      defaultValue: false,\n    },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"shuffledsearch\" name=\"ShuffledSearch\" let:args>\n  <p class=\"form\"><input type=\"text\" bind:value={q} /></p>\n  <ShuffledSearch\n    {...args}\n    {q}\n    {page}\n    bind:loading\n    on:click={({ detail }) => args.onClick(detail)}\n    on:error={({ detail }) => args.onError(detail)}\n  />\n  <p class=\"more\">\n    <button on:click={() => page++} disabled={loading}>Load more</button>\n  </p>\n</Story>\n\n<style>\n  .form {\n    display: flex;\n  }\n\n  .form > input {\n    flex: 1;\n    padding: 0.25em;\n  }\n\n  .more {\n    text-align: center;\n  }\n\n  .more > button {\n    padding: 1em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { Gif, ResultPage, SearchOptions } from './api'\n  import { trending } from './api'\n  import Grid from './Grid.svelte'\n\n  /** Tenor API key. */\n  export let key: SearchOptions['key']\n  /** Search locale. */\n  export let locale: SearchOptions['locale'] = undefined\n  /** Video quality filter. */\n  export let quality: SearchOptions['quality'] = undefined\n  /** Safety filter. */\n  export let safety: SearchOptions['safety'] = undefined\n  /** Aspect ratio filter. */\n  export let ratio: SearchOptions['ratio'] = undefined\n  /** Number of results per page. */\n  export let limit: SearchOptions['limit'] = undefined\n\n  /** Number of pages to display. */\n  export let page = 1\n\n  /** Minimum size for each column, in pixels. The maximum size is `columnSize * 2 + gap`. */\n  export let columnSize: number | undefined = undefined\n  /** Gap between GIFs, in pixels. */\n  export let gap: number | undefined = undefined\n  /** In-line, horizontal scrolling grid. */\n  export let inline: boolean | undefined = undefined\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * GIFs displayed in the grid.\n   *\n   * @readonly\n   */\n  export let gifs: Array<Gif> | undefined = undefined\n\n  /** Latest request performed. */\n  let latestRequest: Promise<ResultPage> | undefined\n\n  /** Pages loaded and cached. */\n  let pages: Array<ResultPage> = []\n\n  const dispatch = createEventDispatcher<{ error: Error }>()\n\n  /** Performs a search when the search term or the number of pages changes. */\n  const update = async () => {\n    while (pages.length < page) {\n      loading = true\n      let localRequest = trending({\n        key,\n        locale,\n        quality,\n        safety,\n        ratio,\n        limit,\n        page: pages[pages.length - 1]?.next,\n      })\n      latestRequest = localRequest\n      // Wait for the search to finish\n      let page = await localRequest\n      // If the current search is not the latest one\n      // (the change term changed in between), ignore the result\n      if (latestRequest !== localRequest) return\n      // Otherwise, add the page at the end of the cache\n      pages = [...pages, page]\n    }\n    // Update the grid\n    gifs = pages.slice(0, page).flatMap(({ results }) => results)\n    loading = false\n  }\n\n  // Perform a search when the search term or the number of pages changes\n  $: if (mounted || retry) {\n    page\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      gifs = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(() => {\n    mounted = true\n  })\n</script>\n\n{#if gifs !== undefined}\n  <Grid {gifs} {columnSize} {gap} {inline} on:click />\n{/if}\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import Trending from '../lib/Trending.svelte'\n\n  let page = 1\n  let loading = false\n</script>\n\n<Meta\n  title=\"Components/Trending\"\n  component={Trending}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    quality: {\n      options: ['low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'medium',\n    },\n    safety: {\n      options: ['off', 'low', 'medium', 'high'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'off',\n    },\n    ratio: {\n      options: ['all', 'wide', 'standard'],\n      control: { type: 'inline-radio' },\n      defaultValue: 'all',\n    },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 20,\n    },\n    columnSize: {\n      control: { type: 'range', min: 10, max: 360, step: 1 },\n      defaultValue: 160,\n    },\n    gap: {\n      control: { type: 'range', min: 0, max: 20, step: 1 },\n      defaultValue: 8,\n    },\n    inline: {\n      control: { type: 'boolean' },\n      defaultValue: false,\n    },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"trending\" name=\"Trending\" let:args>\n  <Trending\n    {...args}\n    {page}\n    bind:loading\n    on:click={({ detail }) => args.onClick(detail)}\n    on:error={({ detail }) => args.onError(detail)}\n  />\n  <p class=\"more\">\n    <button on:click={() => page++} disabled={loading}>Load more</button>\n  </p>\n</Story>\n\n<style>\n  .more {\n    text-align: center;\n  }\n\n  .more > button {\n    padding: 1em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte'\n  import type { SuggestionOptions } from './api'\n  import { trendingTerms } from './api'\n  import Terms from './Terms.svelte'\n\n  /** Tenor API key. */\n  export let key: SuggestionOptions['key']\n  /** Search locale. */\n  export let locale: SuggestionOptions['locale'] = undefined\n  /** Number of results. */\n  export let limit: SuggestionOptions['limit'] = undefined\n\n  /** Keeps the buttons on one line instead of wrapping. */\n  export let scroll = false\n\n  /** Set `retry` to true to retry the last request. */\n  export let retry = false\n  /**\n   * Is the request in progress?\n   *\n   * @readonly\n   */\n  export let loading = true\n  /**\n   * Terms displayed.\n   *\n   * @readonly\n   */\n  export let terms: string[] | undefined = undefined\n\n  const dispatch = createEventDispatcher<{ click: string; error: Error }>()\n\n  const update = async () => {\n    terms = await trendingTerms({ key, locale, limit })\n    loading = false\n  }\n\n  $: if (mounted || retry) {\n    retry = false\n    update().catch((error: Error) => {\n      // If the request fails, tell the parent component\n      terms = undefined\n      dispatch('error', error)\n    })\n  }\n\n  let mounted = false\n  onMount(async () => {\n    mounted = true\n  })\n</script>\n\n{#if terms !== undefined}\n  <Terms {terms} {scroll} on:click />\n{/if}\n","<script>\n  import { Meta, Story } from '@storybook/addon-svelte-csf'\n  import TrendingTerms from '../lib/TrendingTerms.svelte'\n</script>\n\n<Meta\n  title=\"Components/TrendingTerms\"\n  component={TrendingTerms}\n  argTypes={{\n    key: { control: { type: 'text' }, defaultValue: 'LIVDSRZULELA' },\n    locale: { control: { type: 'text' }, defaultValue: 'en_US' },\n    limit: {\n      control: { type: 'range', min: 1, max: 50, step: 1 },\n      defaultValue: 10,\n    },\n    scroll: { control: { type: 'boolean' }, defaultValue: false },\n    onClick: { action: {} },\n    onError: { action: {} },\n  }}\n/>\n\n<Story id=\"trendingterms\" name=\"TrendingTerms\" let:args>\n  <TrendingTerms\n    {...args}\n    on:click={({ detail }) => args.onClick(detail)}\n    on:error={({ detail }) => args.onError(detail)}\n  />\n</Story>\n","import { configure } from '@storybook/svelte';\n    /* // preview entry\nimport '/home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/core-client/dist/esm/globals/polyfills.js';\n// preview entry\nimport '/home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/core-client/dist/esm/globals/globals.js'; */\n\n    import {\n      addDecorator,\n      addParameters,\n      addLoader,\n      addArgTypesEnhancer,\n      addArgsEnhancer\n    } from '@storybook/client-api';\n    import { logger } from '@storybook/client-logger';\n    import * as config_0 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-docs/dist/esm/frameworks/common/config.js'\nimport * as config_1 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-docs/dist/esm/frameworks/svelte/config.js'\nimport * as config_2 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/svelte/dist/esm/client/preview/config'\nimport * as config_3 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-links/dist/esm/preset/addDecorator.js'\nimport * as config_4 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-actions/dist/esm/preset/addDecorator.js'\nimport * as config_5 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-actions/dist/esm/preset/addArgs.js'\nimport * as config_6 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-backgrounds/dist/esm/preset/addDecorator.js'\nimport * as config_7 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-backgrounds/dist/esm/preset/addParameter.js'\nimport * as config_8 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-measure/dist/esm/preset/addDecorator.js'\nimport * as config_9 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/node_modules/@storybook/addon-outline/dist/esm/preset/addDecorator.js'\nimport * as config_10 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/.storybook/preview.js'\n    import * as story_0 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/Autocomplete.stories.svelte'\nimport * as story_1 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/Categories.stories.svelte'\nimport * as story_2 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/MobileKeyboard.stories.svelte'\nimport * as story_3 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/Related.stories.svelte'\nimport * as story_4 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/Search.stories.svelte'\nimport * as story_5 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/ShuffledSearch.stories.svelte'\nimport * as story_6 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/Trending.stories.svelte'\nimport * as story_7 from '/@fs//home/runner/work/svelte-tenor/svelte-tenor/src/stories/TrendingTerms.stories.svelte'\n      \n    const configs = [config_0,config_1,config_2,config_3,config_4,config_5,config_6,config_7,config_8,config_9,config_10]\n    configs.forEach(config => {\n      Object.keys(config).forEach((key) => {\n        const value = config[key];\n        switch (key) {\n          case 'args':\n          case 'argTypes': {\n            return logger.warn('Invalid args/argTypes in config, ignoring.', JSON.stringify(value));\n          }\n          case 'decorators': {\n            return value.forEach((decorator) => addDecorator(decorator, false));\n          }\n          case 'loaders': {\n            return value.forEach((loader) => addLoader(loader, false));\n          }\n          case 'parameters': {\n            return addParameters({ ...value }, false);\n          }\n          case 'argTypesEnhancers': {\n            return value.forEach((enhancer) => addArgTypesEnhancer(enhancer));\n          }\n          case 'argsEnhancers': {\n            return value.forEach((enhancer) => addArgsEnhancer(enhancer))\n          }\n          case 'globals':\n          case 'globalTypes': {\n            const v = {};\n            v[key] = value;\n            return addParameters(v, false);\n          }\n          case 'decorateStory':\n          case 'renderToDOM': {\n            return null; // This key is not handled directly in v6 mode.\n          }\n          default: {\n            // eslint-disable-next-line prefer-template\n            return console.log(key + ' was not supported :( !');\n          }\n        }\n      });\n    })\n    \n    /* TODO: not quite sure what to do with this, to fix HMR\n    if (import.meta.hot) {\n        import.meta.hot.accept();    \n    }\n    */\n    \n    function loadable(key) {\n      return {\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Autocomplete.stories.svelte\": story_0,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Categories.stories.svelte\": story_1,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/MobileKeyboard.stories.svelte\": story_2,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Related.stories.svelte\": story_3,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Search.stories.svelte\": story_4,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/ShuffledSearch.stories.svelte\": story_5,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Trending.stories.svelte\": story_6,\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/TrendingTerms.stories.svelte\": story_7}[key];\n    }\n    \n    Object.assign(loadable, {\n      keys: () => ([\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Autocomplete.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Categories.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/MobileKeyboard.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Related.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Search.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/ShuffledSearch.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Trending.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/TrendingTerms.stories.svelte\"]),\n      resolve: (key) => ({\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Autocomplete.stories.svelte\":\"./src/stories/Autocomplete.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Categories.stories.svelte\":\"./src/stories/Categories.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/MobileKeyboard.stories.svelte\":\"./src/stories/MobileKeyboard.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Related.stories.svelte\":\"./src/stories/Related.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Search.stories.svelte\":\"./src/stories/Search.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/ShuffledSearch.stories.svelte\":\"./src/stories/ShuffledSearch.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/Trending.stories.svelte\":\"./src/stories/Trending.stories.svelte\",\"/home/runner/work/svelte-tenor/svelte-tenor/src/stories/TrendingTerms.stories.svelte\":\"./src/stories/TrendingTerms.stories.svelte\"}[key])\n    });\n    \n    configure(loadable, { hot: import.meta.hot }, false); // not sure if the import.meta.hot thing is correct"],"names":["rawSearch","rawRandom","rawTrending","rawRegisterShare","rawAutocomplete","rawSearchSuggestions","rawTrendingTerms","rawCategories","categories","categoriesApi"],"mappings":"u4BAAA,KAAM,IAAI,UAAoB,CAC1B,KAAM,GAAU,SAAS,cAAc,QAAQ,QAC/C,GAAI,GAAW,EAAQ,UAAY,EAAQ,SAAS,iBAChD,OAEJ,SAAW,KAAQ,UAAS,iBAAiB,6BACzC,EAAe,GAEnB,GAAI,kBAAiB,AAAC,GAAc,CAChC,SAAW,KAAY,GACnB,GAAI,EAAS,OAAS,YAGtB,SAAW,KAAQ,GAAS,WACxB,AAAI,EAAK,UAAY,QAAU,EAAK,MAAQ,iBACxC,EAAe,KAG5B,QAAQ,SAAU,CAAE,UAAW,GAAM,QAAS,KACjD,WAAsB,EAAQ,CAC1B,KAAM,GAAY,GAClB,MAAI,GAAO,WACP,GAAU,UAAY,EAAO,WAC7B,EAAO,gBACP,GAAU,eAAiB,EAAO,gBACtC,AAAI,EAAO,cAAgB,kBACvB,EAAU,YAAc,UACvB,AAAI,EAAO,cAAgB,YAC5B,EAAU,YAAc,OAExB,EAAU,YAAc,cACrB,EAEX,WAAwB,EAAM,CAC1B,GAAI,EAAK,GAEL,OACJ,EAAK,GAAK,GAEV,KAAM,GAAY,EAAa,GAC/B,MAAM,EAAK,KAAM,KAEvB,AAAoB,KC1Cf,KAAM,IAAa,CACxB,QAAS,CAAE,cAAe,cAC1B,SAAU,CACR,SAAU,CACR,MAAO,uBACP,KAAM,mGCqJC,GACX,AAAgB,GAChB,KAAO,IAAoC,MACnC,GAAM,GAAI,KAAI,0BAA0B,cACnC,CAAC,EAAM,IAAU,QAAO,QAAQ,GACrC,IAAU,UAAe,aAAa,IAAI,EAAM,EAAM,iBAEtD,GAAW,KAAM,OAAM,EAAI,eAE7B,EAAS,QAAU,IAAK,MACpB,GAAS,KAAM,GAAS,YACxB,IAAI,OAAM,GAAG,EAAM,SAAS,EAAM,eAGnC,GAAS,QAIP,GAAY,CAEvB,KAAM,EAAS,QACf,OAAQ,EAAS,UACjB,SAAU,EAAS,YACnB,OAAQ,EAAS,UAEjB,kBAAmB,EAAS,sBAC5B,aAAc,EAAS,gBACvB,cAAe,EAAS,kBAExB,WAAY,EAAS,cACrB,cAAe,EAAS,iBACxB,OAAQ,EAAS,6BAsBU,EAAoC,OACxD,IAAU,OAAO,qBAoBK,EAAoC,OAC1D,IAAU,SAAS,qBA8CK,EAAoC,OAC5D,IAAU,WAAW,qBAWU,EAAoC,OACnE,IAAU,kBAAkB,qBAWF,EAAoC,OAC9D,IAAU,aAAa,qBAUI,EAAoC,OAC/D,IAAU,cAAc,qBAWG,EAAoC,OAC/D,IAAU,cAAc,qBA2CJ,EAAoC,OACxD,IAAU,OAAO,GCtP1B,KAAM,IAAiB,CACrB,CAAE,UAAS,QACX,EAAqC,aAErC,QAAS,EAAQ,IAAI,CAAC,CAAE,KAAI,QAAO,sBAAqB,WAAY,MAC5D,GAAU,CAAE,IAAK,OAAQ,OAAQ,OAAQ,KAAM,IAAe,SAC7D,CACL,KACA,YAAa,EAAM,OAAS,EAAI,EAAQ,EACxC,MAAO,EAAM,GAAG,GAAG,QAAa,KAAK,GACrC,OAAQ,EAAM,GAAG,GAAG,QAAa,KAAK,GACtC,IAAK,EAAM,GAAG,GAAG,QAAa,OAGlC,SAuBW,GAAS,MAAO,CAC3B,MACA,IACA,SACA,UACA,SACA,QACA,QACA,UAEA,GACE,KAAMA,IAAU,CACd,MACA,IACA,SACA,cAAe,EACf,SAAU,EACV,QACA,IAAK,EACL,aAAc,UAEhB,GAIS,GAAiB,MAAO,CACnC,MACA,IACA,SACA,UACA,SACA,QACA,QACA,UAEA,GACE,KAAMC,IAAU,CACd,MACA,IACA,SACA,cAAe,EACf,SAAU,EACV,QACA,IAAK,EACL,aAAc,UAEhB,GAIS,GAAW,MAAO,CAC7B,MACA,SACA,UACA,SACA,QACA,QACA,UAEA,GACE,KAAMC,IAAY,CAChB,MACA,SACA,cAAe,EACf,SAAU,EACV,QACA,IAAK,EACL,aAAc,UAEhB,GAIS,GAAgB,KAAO,IAKHC,GAAiB,GAGrC,GAAe,MAAO,CACjC,MACA,IACA,SACA,iBAEOC,IAAgB,CAAE,MAAK,IAAG,SAAQ,WAAU,QAGxC,GAAU,MAAO,CAC5B,MACA,IACA,SACA,iBAEOC,IAAqB,CAAE,MAAK,IAAG,SAAQ,WAAU,QAG7C,GAAgB,MAAO,CAClC,MACA,SACA,iBAKWC,IAAiB,CAAE,MAAK,SAAQ,WAAU,QAG1C,GAAa,MAAO,CAC/B,MACA,OACA,SACA,kBAOOC,IAAc,CAAE,MAAK,OAAM,SAAQ,cAAe,KAAW,KAAK,IACvE,CAAC,CAAE,aAAY,aAAe,KAAM,EAAY,IAAK,sFCrPlD,qKAPuB,KAAM,+BADhC,qFAQG,8CAPuB,KAAM,wFAId,SAAU,uCACP,SAAU,gDAAV,SAAU,uGAP1B,gBAAe,qBAApB,oLADJ,8EACS,iLAAL,qJArBS,YACA,SAAS,WAEd,GAAW,IAEX,EAAS,OACT,GAAO,kBACA,KAAQ,GAAK,EAAS,IAAQ,GAAK,EAAO,EAAK,WAAW,GAAM,OACrE,GAAQ,IAAO,WAAa,IAAM,EAClC,EAAU,IAAO,QAAa,GAAK,EACnC,EAAQ,GAAO,KAAY,EAC3B,EAAI,GAAM,EAAM,GAAM,EAAQ,GAAM,EACpC,EAAK,GACT,KAAK,IAAI,IAAM,KAAK,IAAI,GAAM,KAAK,MAAO,EAAI,IAAQ,KACnD,SAAS,IACT,SAAS,EAAG,eACN,EAAE,KAAO,EAAE,KAAS,EAAE,YAS7B,EAAS,QAAS,seCqCrB,OAAU,oFAAV,OAAU,oMA5DF,UAEA,QAEA,SAAsC,WAEtC,QAAoC,WAGpC,SAAS,OAGT,QAAQ,OAMR,UAAU,OAMV,QAA8B,UAGrC,OAEE,GAAW,IAGX,gBACJ,EAAU,OACN,GAAe,IAAe,MAAK,IAAG,SAAQ,UAClD,EAAgB,KACZ,QAAgB,GAGhB,IAAkB,QACtB,EAAQ,OACR,EAAU,SAaR,GAAU,GACd,WACE,EAAU,uTAZL,IAAW,SAEhB,EAAQ,IACR,IAAS,MAAO,QAEd,EAAQ,QACR,EAAS,QAAS,oMC9Bd,2VAHR,SACE,WAA+B,uFAAA,UAAA,kCAEzB,+NAlBG,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,QAAU,SAAW,KAAM,WAAa,aAAc,IACtD,SAAW,WACX,SAAW,wcAfT,GAAI,gBAqByB,mCAIhB,aACX,EAAK,QAAQ,OACb,EAAI,QAEO,aACX,EAAK,QAAQ,4PCgCsB,cAA6B,WAC7D,0BAAL,iLADJ,sEACS,uBAAL,+HAAA,sBADqC,+CAA6B,4EAO/D;cAHI,sJAFP,0EAKG;cAHI,wFALR,OAAe,+EAAf,OAAe,oIA3DP,UAMA,OAA4C,WAE5C,SAAkC,WAElC,SAAkC,WAOlC,aAAa,QAMb,MAAM,MAGN,QAAQ,OAMR,UAAU,kBAEVC,EACT,eAEI,GAAW,IAEX,gBACJA,OAAmBC,KAAgB,MAAK,OAAM,SAAQ,gBACtD,EAAU,QAYR,GAAU,GACd,iBACE,EAAU,iBAUU,EAAS,QAAS,uUArBjC,IAAW,SAChB,EAAQ,IACR,IAAS,MAAO,QAEdD,EAAa,QACb,EAAS,QAAS,iNCnBhB,kRAAA,gMA7BK,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,MACE,SAAU,WAAY,YACtB,SAAW,KAAM,gBACjB,aAAc,YAEhB,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,QACE,SAAU,MAAO,MAAO,SAAU,QAClC,SAAW,KAAM,gBACjB,aAAc,OAEhB,YACE,SAAW,KAAM,QAAS,IAAK,GAAI,IAAK,IAAK,KAAM,GACnD,aAAc,KAEhB,KACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,GAEhB,SAAW,WACX,SAAW,ucAOE,YAAa,EAAK,QAAQ,OAC1B,YAAa,EAAK,QAAQ,0OC9B3B,qFAAhB,uEAAgB,+GALH,0FAEL,cAAa,QAAO,SAAQ,IAAK,GAAQ,oOCuEjB,KAAK,KAC5B,KAAa,KAAI,OAAU,KAAI,MAAS,IAAiB,6OAF9D,oIAC4B,KAAK,KAC5B,KAAa,KAAI,OAAU,KAAI,MAAS,IAAiB,4KAR/C,cACH,cACA,iBAGP,gBAAa,KAAI,mBAAtB,6OARJ,8GAQS,0FALU,gDACH,4CACA,0DAGZ,4IA9DI,IAAiB,yBAFZ,aAAa,OAQpB,EAAU,IAOH,MAAM,MAON,SAAS,OAGT,kBAEL,GAAW,IAGX,EAAS,OAET,gBACE,MAAe,wBAEf,EAAG,cAAgB,EAAO,UAC9B,GAAU,EAAO,GAAI,EAAG,kBAClB,GAAU,OACb,iBAAiB,GACjB,iBAAiB,yBACjB,MAAM,KAAK,OACR,EAAY,EAAG,YAAe,GAAU,GAAK,MAEnD,EACI,EAAY,EAAY,IAAiB,GAAQ,EAAa,KAEpE,SAAS,QAAQ,IAGf,UACE,EAAS,UAAU,WAoBL,EAAS,QAAS,4nBC2BnC,OAAS,oFAAT,OAAS,oMApGD,UAEA,QAEA,SAAkC,WAElC,UAAoC,WAEpC,SAAkC,WAElC,QAAgC,WAEhC,QAAgC,WAGhC,OAAO,MAGP,aAAiC,WAEjC,MAA0B,WAE1B,SAA8B,WAG9B,QAAQ,OAMR,UAAU,OAMV,OAA+B,UAGtC,EAGA,UAEE,GAAW,IAGX,sBACG,EAAM,OAAS,QACpB,EAAU,OACN,GAAe,IACjB,MACA,IACA,SACA,UACA,SACA,QACA,QACA,KAAR,GAAc,EAAM,EAAM,OAAS,MAAnC,MAAA,kBAAA,EAAuC,OAEjC,EAAgB,KAEZ,QAAa,MAGb,IAAkB,SAEtB,MAAY,EAAO,OAGrB,EAAO,EAAM,MAAM,EAAG,GAAM,UAAW,aAAc,QACrD,EAAU,QAsBR,GAAU,GACd,YACE,EAAU,gfAlBV,EAAO,GACP,wBAIK,IAAW,SAGhB,EAAQ,IACR,IAAS,MAAO,QAEd,EAAO,QACP,EAAS,QAAS,yQCDf,SAAU,kWAoBb,wEAlBO,MAAS,QAAU,gBAEd,MAAS,QAAU,oCAGxB,MAAS,QAAU,0GAN1B,yHAMO,MAAS,QAAU,oHAFrB,MAAS,qEAAT,MAAS,wDAFT,MAAM,uEAAN,MAAM,4DAYJ,MAAS,4EAPZ,sEAOG,MAAS,mEAyCb,MAAS,4EANZ,sEAMG,MAAS,4FA5DC,eACH,kBAET,OAAS,8NAoCJ,kTAcH,MAAS,QAAU,sJAYT,MAAS,0KAnE5B,kDAsDE,6BAWE,WAGc,6DA/DX,OAAS,scAkDP,MAAS,QAAU,8EAYT,MAAS,6CACV,wBAlEC,mDACH,kLAtFH,UAEA,IAAwB,OAExB,SAAkC,WAElC,UAAoC,WAEpC,SAAkC,WAElC,QAAgC,WAEhC,QAAgC,WAGhC,OAAO,MAOP,aAAa,QAMb,MAAM,MAMN,YAAY,OAEZ,YAgBT,YAAa,eACb,MAAO,QACP,MAAO,iCACP,MAAO,aAQE,UAAU,OAMV,OAA+B,UAGtC,EACA,EAAQ,QAEN,GAAW,OAEb,GACJ,OACM,GAAS,GAAW,EAAM,4BAqBpB,EAAQ,aACR,EAAQ,oHA4BL,aACX,EAAS,QAAS,GACb,IAAgB,MAAK,GAAI,EAAO,GAAI,IAAG,gBAEjC,kBACX,EAAQ,YAQJ,EAAS,wBASD,8DACD,stBCrGT,yQAAA,mMAnDK,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,SACE,SAAU,MAAO,SAAU,QAC3B,SAAW,KAAM,gBACjB,aAAc,UAEhB,QACE,SAAU,MAAO,MAAO,SAAU,QAClC,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAU,MAAO,OAAQ,YACzB,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,YACE,SAAW,KAAM,QAAS,IAAK,GAAI,IAAK,IAAK,KAAM,GACnD,aAAc,KAEhB,KACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,GAEhB,WACE,SAAW,KAAM,WACjB,aAAc,IAEhB,UACE,SAAW,KAAM,UACjB,cACE,YAAa,eACb,MAAO,QACP,MAAO,iCACP,MAAO,UAGX,SAAW,WACX,SAAW,+cAOE,YAAa,EAAK,QAAQ,MACvB,EAAK,mdCOpB,OAAU,oFAAV,OAAU,oMA5DF,UAEA,QAEA,SAAsC,WAEtC,QAAoC,WAGpC,SAAS,OAGT,QAAQ,OAMR,UAAU,OAMV,QAA8B,UAGrC,OAEE,GAAW,IAGX,gBACJ,EAAU,OACN,GAAe,IAAU,MAAK,IAAG,SAAQ,UAC7C,EAAgB,KACZ,QAAgB,GAGhB,IAAkB,QACtB,EAAQ,OACR,EAAU,SAaR,GAAU,GACd,WACE,EAAU,uTAZL,IAAW,SAEhB,EAAQ,IACR,IAAS,MAAO,QAEd,EAAQ,QACR,EAAS,QAAS,oMC9Bd,2VAHR,SACE,WAA+B,uFAAA,UAAA,kCAEzB,0NAlBG,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,QAAU,SAAW,KAAM,WAAa,aAAc,IACtD,SAAW,WACX,SAAW,8bAfT,GAAI,gBAqByB,mCAIhB,aACX,EAAK,QAAQ,OACb,EAAI,QAEO,YAAa,EAAK,QAAQ,wMCqBrC,iYAQ+C,0GAAT,4EAV5C,SAAgB,WAA+B,iCAS/C,SACE,gGAV6C,UAAA,oCAEzC,uHAQsC,wNAnDjC,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,SACE,SAAU,MAAO,SAAU,QAC3B,SAAW,KAAM,gBACjB,aAAc,UAEhB,QACE,SAAU,MAAO,MAAO,SAAU,QAClC,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAU,MAAO,OAAQ,YACzB,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,YACE,SAAW,KAAM,QAAS,IAAK,GAAI,IAAK,IAAK,KAAM,GACnD,aAAc,KAEhB,KACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,GAEhB,QACE,SAAW,KAAM,WACjB,aAAc,IAEhB,SAAW,WACX,SAAW,8bA3CT,GAAI,QACJ,EAAO,EACP,EAAU,gBA8CiC,kEAMhC,YAAa,EAAK,QAAQ,OAC1B,YAAa,EAAK,QAAQ,WAGf,mhBC6CvB,OAAS,oFAAT,OAAS,oMApGD,UAEA,QAEA,SAAkC,WAElC,UAAoC,WAEpC,SAAkC,WAElC,QAAgC,WAEhC,QAAgC,WAGhC,OAAO,MAGP,aAAiC,WAEjC,MAA0B,WAE1B,SAA8B,WAG9B,QAAQ,OAMR,UAAU,OAMV,OAA+B,UAGtC,EAGA,UAEE,GAAW,IAGX,sBACG,EAAM,OAAS,QACpB,EAAU,OACN,GAAe,IACjB,MACA,IACA,SACA,UACA,SACA,QACA,QACA,KAAR,GAAc,EAAM,EAAM,OAAS,MAAnC,MAAA,kBAAA,EAAuC,OAEjC,EAAgB,KAEZ,QAAa,MAGb,IAAkB,SAEtB,MAAY,EAAO,OAGrB,EAAO,EAAM,MAAM,EAAG,GAAM,UAAW,aAAc,QACrD,EAAU,QAsBR,GAAU,GACd,YACE,EAAU,gfAlBV,EAAO,GACP,wBAIK,IAAW,SAGhB,EAAQ,IACR,IAAS,MAAO,QAEd,EAAO,QACP,EAAS,QAAS,kRC3ChB,iYAQ+C,0GAAT,4EAV5C,SAAgB,WAA+B,iCAS/C,SACE,gGAV6C,UAAA,oCAEzC,uHAQsC,gOAnDjC,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,SACE,SAAU,MAAO,SAAU,QAC3B,SAAW,KAAM,gBACjB,aAAc,UAEhB,QACE,SAAU,MAAO,MAAO,SAAU,QAClC,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAU,MAAO,OAAQ,YACzB,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,YACE,SAAW,KAAM,QAAS,IAAK,GAAI,IAAK,IAAK,KAAM,GACnD,aAAc,KAEhB,KACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,GAEhB,QACE,SAAW,KAAM,WACjB,aAAc,IAEhB,SAAW,WACX,SAAW,8cA3CT,GAAI,QACJ,EAAO,EACP,EAAU,gBA8CiC,kEAMhC,YAAa,EAAK,QAAQ,OAC1B,YAAa,EAAK,QAAQ,WAGf,mhBCkCvB,OAAS,oFAAT,OAAS,oMAzFD,UAEA,SAAkC,WAElC,UAAoC,WAEpC,SAAkC,WAElC,QAAgC,WAEhC,QAAgC,WAGhC,OAAO,MAGP,aAAiC,WAEjC,MAA0B,WAE1B,SAA8B,WAG9B,QAAQ,OAMR,UAAU,OAMV,OAA+B,UAGtC,EAGA,UAEE,GAAW,IAGX,sBACG,EAAM,OAAS,QACpB,EAAU,OACN,GAAe,IACjB,MACA,SACA,UACA,SACA,QACA,QACA,KAAR,GAAc,EAAM,EAAM,OAAS,MAAnC,MAAA,kBAAA,EAAuC,OAEjC,EAAgB,KAEZ,QAAa,MAGb,IAAkB,SAEtB,MAAY,EAAO,OAGrB,EAAO,EAAM,MAAM,EAAG,GAAM,UAAW,aAAc,QACrD,EAAU,QAcR,GAAU,GACd,YACE,EAAU,wdAZL,IAAW,SAEhB,EAAQ,IACR,IAAS,MAAO,QAEd,EAAO,QACP,EAAS,QAAS,qQClChB,4VAO+C,wBAAT,8FAD5C,SACE,yFAPI,yGAOsC,wMAjDjC,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,SACE,SAAU,MAAO,SAAU,QAC3B,SAAW,KAAM,gBACjB,aAAc,UAEhB,QACE,SAAU,MAAO,MAAO,SAAU,QAClC,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAU,MAAO,OAAQ,YACzB,SAAW,KAAM,gBACjB,aAAc,OAEhB,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,YACE,SAAW,KAAM,QAAS,IAAK,GAAI,IAAK,IAAK,KAAM,GACnD,aAAc,KAEhB,KACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,GAEhB,QACE,SAAW,KAAM,WACjB,aAAc,IAEhB,SAAW,WACX,SAAW,icA1CT,GAAO,EACP,EAAU,6CAkDC,YAAa,EAAK,QAAQ,OAC1B,YAAa,EAAK,QAAQ,WAGf,gdCNvB,OAAU,oFAAV,OAAU,oMA9CF,UAEA,SAAsC,WAEtC,QAAoC,WAGpC,SAAS,OAGT,QAAQ,OAMR,UAAU,OAMV,QAA8B,eAEnC,GAAW,IAEX,gBACJ,OAAc,KAAgB,MAAK,SAAQ,eAC3C,EAAU,QAYR,GAAU,GACd,gBACE,EAAU,mSAXL,IAAW,SAChB,EAAQ,IACR,IAAS,MAAO,QAEd,EAAQ,QACR,EAAS,QAAS,oLCpBhB,kRAAA,mMAhBK,aAET,KAAO,SAAW,KAAM,QAAU,aAAc,gBAChD,QAAU,SAAW,KAAM,QAAU,aAAc,SACnD,OACE,SAAW,KAAM,QAAS,IAAK,EAAG,IAAK,GAAI,KAAM,GACjD,aAAc,IAEhB,QAAU,SAAW,KAAM,WAAa,aAAc,IACtD,SAAW,WACX,SAAW,6cAOE,YAAa,EAAK,QAAQ,OAC1B,YAAa,EAAK,QAAQ,oJCSvC,KAAM,IAAU,CAAC,GAAS,GAAS,GAAS,GAAS,GAAS,GAAS,GAAS,GAAS,GAAS,GAAS,IAC3G,GAAQ,QAAQ,GAAU,CACxB,OAAO,KAAK,GAAQ,QAAQ,AAAC,GAAQ,CACnC,KAAM,GAAQ,EAAO,GACrB,OAAQ,OACD,WACA,WACH,MAAO,IAAO,KAAK,6CAA8C,KAAK,UAAU,QAE7E,aACH,MAAO,GAAM,QAAQ,AAAC,GAAc,GAAa,EAAW,SAEzD,UACH,MAAO,GAAM,QAAQ,AAAC,GAAW,GAAU,EAAQ,SAEhD,aACH,MAAO,IAAc,MAAK,GAAS,QAEhC,oBACH,MAAO,GAAM,QAAQ,AAAC,GAAa,GAAoB,QAEpD,gBACH,MAAO,GAAM,QAAQ,AAAC,GAAa,GAAgB,QAEhD,cACA,cAAe,CAClB,KAAM,GAAI,GACV,SAAE,GAAO,EACF,GAAc,EAAG,QAErB,oBACA,cACH,MAAO,cAIP,MAAO,SAAQ,IAAI,EAAM,gCAYjC,YAAkB,EAAK,CACrB,MAAO,CAAC,sFAAuF,GAAQ,oFAAqF,GAAQ,wFAAyF,GAAQ,iFAAkF,GAAQ,gFAAiF,GAAQ,wFAAyF,GAAQ,kFAAmF,GAAQ,uFAAwF,IAAS,GAGvvB,OAAO,OAAO,GAAU,CACtB,KAAM,IAAO,CAAC,sFAAsF,oFAAoF,wFAAwF,iFAAiF,gFAAgF,wFAAwF,kFAAkF,wFAC3lB,QAAS,AAAC,GAAS,EAAC,sFAAsF,4CAA4C,oFAAoF,0CAA0C,wFAAwF,8CAA8C,iFAAiF,uCAAuC,gFAAgF,sCAAsC,wFAAwF,8CAA8C,kFAAkF,wCAAwC,uFAAuF,+CAA8C,KAG/gC,GAAU,GAAU,CAAE,IAAK"}